# -*- coding: utf-8 -*-
"""Caps-ML INI YA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16xNPODae4kgG-FuGz_PDcLsDg91bcC7R

### Import Libraries
"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout

from sklearn.model_selection import train_test_split # Import train_test_split
import pandas as pd
import numpy as np
from imblearn.over_sampling import SMOTE
import matplotlib.pyplot as plt
import seaborn as sns

!pip install tensorflowjs
import tensorflowjs as tfjs

import numpy as np
from keras.models import Sequential
from keras.layers import Dense
import tensorflow as tf

from keras.models import Sequential
from keras.layers import Dense, InputLayer  # Mengimpor InputLayer
from sklearn.model_selection import train_test_split # Import train_test_split

"""### Data Loading (data yang sudah bersih)"""

dataset = pd.read_csv('/content/datasetcapscleanfix.csv')
dataset.head()

dataset.info()

# Hitung 0 dan 1nya
print(dataset['SmartHomeEfficiency'].value_counts())

coba = dataset.copy()

"""### Prepocessing"""

# Drop data yang smarthomeefficiency 0 sesuaikan dengan jumlah 1

import pandas as pd
import matplotlib.pyplot as plt
# Filter data where SmartHomeEfficiency is 1
df_ones = coba[coba['SmartHomeEfficiency'] == 1]

# Count the number of samples with SmartHomeEfficiency = 1
count_ones = len(df_ones)

# Filter data where SmartHomeEfficiency is 0
df_zeros = coba[coba['SmartHomeEfficiency'] == 0]

# Randomly sample the same number of samples as count_ones from df_zeros
df_zeros_sampled = df_zeros.sample(n=count_ones, random_state=42) # Use a random_state for reproducibility

# Combine the sampled dataframes
coba = pd.concat([df_ones, df_zeros_sampled])

# Verify the distribution of the target variable in the new dataframe
print("\nNew distribution of SmartHomeEfficiency:")
print(coba['SmartHomeEfficiency'].value_counts())

# Plot the new distribution
plt.figure(figsize=(8, 6))
sns.countplot(x='SmartHomeEfficiency', data=coba)
plt.title('Jumlah Data dengan SmartHomeEfficiency (Balanced)')
plt.xlabel('SmartHomeEfficiency')
plt.ylabel('Jumlah Data')
plt.show()

# Drop non-numerical columns
X = coba.drop(columns=['SmartHomeEfficiency', 'Device ID', 'Device Type', 'Timestamp', 'On/Off Status'])  # Features
y = coba['SmartHomeEfficiency']

"""**Splitting Data**"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Tampilkan bentuk set pelatihan dan set uji untuk memastikan split
print(f"Training set shape: X_train={X_train.shape}, y_train={y_train.shape}")
print(f"Test set shape: X_test={X_test.shape}, y_test={y_test.shape}")

# SMOTE untuk data train saja
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

# Cek Balancing data train
print(y_train_resampled.value_counts())

"""### Data Modeling"""

input_dim = X_train.shape[1]

print(X.shape)

# Membuat model dengan 1 hidden layer menggunakan batch_input_shape pada InputLayer
model1 = Sequential([
    InputLayer(batch_input_shape=(None, input_dim)),
    Dense(16, activation='relu'),  # Layer tersembunyi
    Dense(1, activation='sigmoid')  # Output layer untuk klasifikasi biner
])

model1.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

print("Training Model 1 (1 hidden layer)...")
model1.fit(X_train, y_train, epochs=50, batch_size=4, verbose=0)

# Evaluasi Model 1 untuk training dan testing
loss1, acc1 = model1.evaluate(X_train, y_train, verbose=0)
print(f"Model 1 Training Accuracy: {acc1:.4f}")

loss1, acc1 = model1.evaluate(X_test, y_test, verbose=0)
print(f"Model 1 Test Accuracy: {acc1:.4f}")

y_pred1 = (model1.predict(X_test) > 0.5).astype("int32")
print("Classification report Model 1:")
print(classification_report(y_test, y_pred1))

"""### Inferensi"""

# Fungsi untuk menghitung tarif per KWh berdasarkan daya listrik
def get_tarif_per_kwh(daya_listrik):
    if daya_listrik == 450:
        return 415
    elif daya_listrik == 900:
        return 1352
    elif daya_listrik == 1300:
        return 1444
    elif daya_listrik == 2200:
        return 1444
    else:
        print("Daya listrik tidak valid, tarif default digunakan (Rp. 1.444/kWh).")
        return 1444

# Fungsi untuk menghitung konsumsi energi berdasarkan daya perangkat dan durasi penggunaan
def calculate_energy_consumption(daya_perangkat, durasi_penggunaan):
    # Konsumsi energi = daya perangkat (Watt) * durasi (jam) / 1000 (untuk mengkonversi ke kWh)
    return (daya_perangkat * durasi_penggunaan) / 1000  # dalam kWh

# Fungsi untuk meminta input dari pengguna
def get_user_input():
    # Meminta input dari pengguna
    device_id = input("Masukkan Device ID: ")
    device_type = input("Masukkan Device Type (misalnya, AC, Heater, Refrigerator): ")

    # Input daya perangkat (Watt)
    daya_perangkat = int(input(f"Masukkan daya perangkat {device_type} (Watt): "))
    # Input durasi penggunaan (jam)
    usage_duration = float(input("Masukkan Usage Duration (hour): "))

    # Menghitung konsumsi energi
    energy_consumption = calculate_energy_consumption(daya_perangkat, usage_duration)

    # Input daya listrik rumah
    daya_listrik = int(input("Masukkan daya listrik rumah (450, 900, 1300, 2200): "))

    # Menghitung tarif per kWh berdasarkan daya listrik
    tarif_per_kwh = get_tarif_per_kwh(daya_listrik)

    # Menghitung Energy Cost (Rp)
    energy_cost = energy_consumption * tarif_per_kwh  # Menggunakan tarif per kWh dari daya listrik

    # Mengembalikan data dalam bentuk list (fitur input tanpa Device ID, Device Type, Timestamp, On/Off Status)
    return [energy_consumption, usage_duration, energy_cost]  # Hanya mengembalikan 3 fitur


# Mendapatkan input dari pengguna
user_input = get_user_input()

# Mengubah input menjadi array untuk prediksi
X_new = np.array([user_input])  # Data fitur input sekarang (1, 3)

# Model 1: NN dengan 1 hidden layer
# Asumsi bahwa model1 sudah dilatih sebelumnya dengan data training yang relevan.
model1 = Sequential([
    Dense(16, activation='relu', input_shape=(3,)),  # input_dim=3 untuk 3 fitur input
    Dense(1, activation='sigmoid')  # Output 1 untuk klasifikasi 0 atau 1
])

model1.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Melakukan prediksi dengan model yang sudah dilatih
prediksi = model1.predict(X_new)

# Menampilkan hasil prediksi
print(f"Hasil prediksi untuk data yang dimasukkan: {prediksi[0][0]} (Probabilitas efisien)")

# Menampilkan hasil prediksi sebagai 0 atau 1
if prediksi[0][0] >= 0.5:
    print("Prediksi: Perangkat Tidak Efisien (0)")
else:
    print("Prediksi: Perangkat Efisien (1)")

"""**Output**"""

# Diagram bar dataset

# Pastikan kolom 'Timestamp' ada dan dalam format datetime
coba['Timestamp'] = pd.to_datetime(coba['Timestamp'])

# Ekstrak komponen tanggal
coba['Date'] = coba['Timestamp'].dt.date
coba['Month'] = coba['Timestamp'].dt.month
coba['Year'] = coba['Timestamp'].dt.year

# Diagram bar untuk jumlah data per bulan
plt.figure(figsize=(10, 6))
sns.countplot(x='Month', data=coba)
plt.title('Distribusi Data per Bulan')
plt.xlabel('Bulan')
plt.ylabel('Jumlah Data')
plt.xticks(ticks=range(12), labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
plt.show()

# Diagram bar untuk jumlah data per tahun
plt.figure(figsize=(8, 6))
sns.countplot(x='Year', data=coba)
plt.title('Distribusi Data per Tahun')
plt.xlabel('Tahun')
plt.ylabel('Jumlah Data')
plt.show()

# Diagram garis tanggal 1 januari -31 januari 2024

# Filtering data for January 2024
january_2024_data = coba[(coba['Year'] == 2024) & (coba['Month'] == 1)]

# Group by date and count the number of entries
data_per_day_january = january_2024_data.groupby('Date').size()

# Create a date range for January 1 to January 31, 2024
january_dates = pd.date_range(start='2024-01-01', end='2024-01-31').date

# Reindex the data_per_day_january to include all dates in January, filling missing dates with 0
data_per_day_january = data_per_day_january.reindex(january_dates, fill_value=0)

# Create the line plot
plt.figure(figsize=(15, 6))
data_per_day_january.plot(kind='line')
plt.title('Jumlah Data per Hari di Bulan Januari 2024')
plt.xlabel('Tanggal')
plt.ylabel('Jumlah Data')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Menambahkan kolom 'Month' dan 'Year' dari kolom 'Timestamp' pada dataframe coba
coba['Month'] = coba['Timestamp'].dt.month
coba['Year'] = coba['Timestamp'].dt.year

# Kelompokkan data berdasarkan bulan dan tahun
monthly_analysis = coba.groupby(['Year', 'Month'])

# Hitung rata-rata Energy Consumption dan Energy Cost per perangkat per bulan
monthly_summary = monthly_analysis[['Energy Consumption (kWh)', 'Energy Cost (Rp)']].mean()

def get_efficiency_result(group):
    if group['SmartHomeEfficiency'].sum() > len(group) / 2:  # Jika mayoritas 0 (tidak hemat)
        return 'Penggunaan Energy bulan ini TIDAK HEMAT (BOROS)'
    else:
        return 'Penggunaan Energy bulan ini HEMAT'  # Jika mayoritas 1 ( hemat)

# Apply fungsi untuk menentukan mayoritas
monthly_summary['Result'] = monthly_analysis.apply(get_efficiency_result)

# Reset index agar kolom 'Year' dan 'Month' menjadi kolom biasa
monthly_summary.reset_index(inplace=True)

# Tampilkan hasil analisis bulanan
print("\nAnalisis Bulanan:")
print(monthly_summary)

# Analisis bulanan

def get_month_name(month_number):
    month_names = {
        1: 'Januari', 2: 'Februari', 3: 'Maret', 4: 'April',
        5: 'Mei', 6: 'Juni', 7: 'Juli', 8: 'Agustus',
        9: 'September', 10: 'Oktober', 11: 'November', 12: 'Desember'
    }
    return month_names.get(month_number, 'Bulan tidak valid')

def analyze_month(data, year, month_number):
    """
    Melakukan analisis bulanan untuk konsumsi dan biaya energi.

    Args:
        data (pd.DataFrame): DataFrame yang mengandung data energi.
        year (int): Tahun yang akan dianalisis.
        month_number (int): Nomor bulan yang akan dianalisis (1-12).
    """
    month_name = get_month_name(month_number)

    # Filter data untuk tahun dan bulan yang dipilih
    monthly_data = data[(data['Year'] == year) & (data['Month'] == month_number)]

    if monthly_data.empty:
        print(f"\nTidak ada data untuk bulan {month_name} tahun {year}.")
        return

    # Hitung rata-rata Energy Consumption dan Energy Cost per perangkat
    avg_energy_consumption_per_device = monthly_data['Energy Consumption (kWh)'].mean()
    avg_energy_cost_per_device = monthly_data['Energy Cost (Rp)'].mean()

    print(f"\nAnalisis untuk Bulan: {month_name} {year}")
    print(f"Energy Consumption (Rata-rata energyconsumption perdevice): {avg_energy_consumption_per_device:.4f} kWh")
    print(f"Energy Cost (Rata-rata energycost perdevice): Rp {avg_energy_cost_per_device:,.2f}")

    # Menentukan efisiensi bulan berdasarkan mayoritas SmartHomeEfficiency
    efficiency_counts = monthly_data['SmartHomeEfficiency'].value_counts()
    if 0 in efficiency_counts and 1 in efficiency_counts:
      if efficiency_counts[0] > efficiency_counts[1]:
          print("Hasil Efisiensi: Penggunaan Energy bulan ini HEMAT")
      else:
          print("Hasil Efisiensi: Penggunaan Energy bulan ini TIDAK HEMAT")
    elif 0 in efficiency_counts:
         print("Hasil Efisiensi: Penggunaan Energy bulan ini HEMAT")
    elif 1 in efficiency_counts:
         print("Hasil Efisiensi: Penggunaan Energy bulan ini TIDAK HEMAT")
    else:
         print("Tidak ada data efisiensi untuk bulan ini.")


analyze_month(coba, 2024, 1)

"""### Convert menyimpan model"""

# Menyimpan model ke dalam format TensorFlow.js
tfjs.converters.save_keras_model(model1, 'path_to_save_model/tfjs_model')

# Menyimpan model ke dalam format JSON
model_json = model1.to_json()

# Menyimpan model JSON ke file
with open("model1.json", "w") as json_file:
    json_file.write(model_json)

# Menyimpan bobot model ke dalam file HDF5
model1.save_weights("model1.weights.h5")

# Save the trained model to an HDF5 file
model1.save('model.h5')
print("Model model1 telah disimpan sebagai model.h5")
